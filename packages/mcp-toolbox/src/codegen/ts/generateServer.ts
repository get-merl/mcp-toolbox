import fs from "node:fs/promises";
import path from "node:path";
import { toCamelCase, toPascalCase } from "./names.js";
import { jsonSchemaToTsInterface } from "./jsonSchemaToTs.js";
import type { IntrospectedServer } from "../../introspect/types.js";

export async function generateServerTs(args: {
  outDir: string;
  serverSlug: string;
  serverName: string;
  snapshot: IntrospectedServer;
}) {
  const serverDir = path.join(args.outDir, "servers", args.serverSlug);
  const toolsDir = path.join(serverDir, "tools");
  await fs.mkdir(toolsDir, { recursive: true });

  const usedNames = new Map<string, number>();
  const exports: string[] = [];

  for (const tool of args.snapshot.tools) {
    const baseFn = toCamelCase(tool.name);
    const n = usedNames.get(baseFn) ?? 0;
    usedNames.set(baseFn, n + 1);
    const fnName = n === 0 ? baseFn : `${baseFn}__${n + 1}`;

    const inputTypeName = `${toPascalCase(fnName)}Input`;
    const outputTypeName = `${toPascalCase(fnName)}Output`;
    const fileName = `${fnName}.ts`;
    const filePath = path.join(toolsDir, fileName);

    const jsdocLines: string[] = [];
    jsdocLines.push("/**");
    if (tool.description)
      jsdocLines.push(` * ${escapeJSDoc(tool.description)}`);
    jsdocLines.push(" *");
    jsdocLines.push(` * MCP server: \`${escapeJSDoc(args.serverName)}\``);
    jsdocLines.push(` * MCP tool: \`${escapeJSDoc(tool.name)}\``);
    jsdocLines.push(` * @param input Tool input`);
    jsdocLines.push(` * @returns Tool output`);
    jsdocLines.push(" */");

    // Generate input and output types (async)
    const inputType = await jsonSchemaToTsInterface(inputTypeName, tool.inputSchema);
    const outputType = tool.outputSchema
      ? await jsonSchemaToTsInterface(outputTypeName, tool.outputSchema)
      : `export type ${outputTypeName} = unknown;\n`;

    const ts = [
      `#!/usr/bin/env tsx`,
      `import { callMcpTool } from "@merl-ai/mcp-toolbox-runtime";`,
      `import { fileURLToPath } from "node:url";`,
      `import { readFileSync } from "node:fs";`,
      ``,
      `// Generated by mcp-toolbox. Do not edit by hand.`,
      ``,
      inputType,
      outputType,
      ``,
      ...jsdocLines,
      `export async function ${fnName}(input: ${inputTypeName}): Promise<${outputTypeName}> {`,
      `  return await callMcpTool<${outputTypeName}>({`,
      `    serverName: ${JSON.stringify(args.serverName)},`,
      `    toolName: ${JSON.stringify(tool.name)},`,
      `    input,`,
      `  });`,
      `}`,
      ``,
      `// CLI execution block`,
      `if (process.argv[1] && fileURLToPath(import.meta.url) === process.argv[1]) {`,
      `  (async () => {`,
      `    try {`,
      `      let inputStr = "";`,
      `      if (process.stdin.isTTY) {`,
      `        // No stdin available, use empty object`,
      `        inputStr = "{}";`,
      `      } else {`,
      `        // Read from stdin (file descriptor 0)`,
      `        try {`,
      `          inputStr = readFileSync(0, "utf-8").trim();`,
      `        } catch {`,
      `          // Fallback if readFileSync fails`,
      `          inputStr = "";`,
      `        }`,
      `        if (!inputStr) {`,
      `          inputStr = "{}";`,
      `        }`,
      `      }`,
      `      `,
      `      const input = JSON.parse(inputStr) as ${inputTypeName};`,
      `      const result = await ${fnName}(input);`,
      `      console.log(JSON.stringify(result, null, 2));`,
      `      process.exit(0);`,
      `    } catch (error) {`,
      `      console.error("Error:", error instanceof Error ? error.message : String(error));`,
      `      if (error instanceof Error && error.stack) {`,
      `        console.error(error.stack);`,
      `      }`,
      `      process.exit(1);`,
      `    }`,
      `  })();`,
      `}`,
      ``,
    ].join("\n");

    await fs.writeFile(filePath, ts, "utf-8");
    await fs.chmod(filePath, 0o755);
    exports.push(`export * from "./tools/${fnName}";`);
  }

  const indexTs = [
    `// Generated by mcp-toolbox. Do not edit by hand.`,
    `// serverName: ${args.serverName}`,
    ``,
    ...exports,
    ``,
  ].join("\n");

  await fs.writeFile(path.join(serverDir, "index.ts"), indexTs, "utf-8");
}

function escapeJSDoc(s: string) {
  // Avoid closing the block comment accidentally.
  return s.replaceAll("*/", "*\\/");
}
