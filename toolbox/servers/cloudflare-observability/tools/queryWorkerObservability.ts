#!/usr/bin/env tsx
import { callMcpTool } from "@merl-ai/mcp-toolbox-runtime";
import { fileURLToPath } from "node:url";
import { readFileSync } from "node:fs";

// Generated by mcp-toolbox. Do not edit by hand.

export interface QueryworkerobservabilityInput {
  query: {
    queryId: string;
    /**
     * ## Examples by View Type
     * 		### Events View
     * 		- "Show me all errors for the worker api-proxy in the last 30 minutes"
     * 		- "Show events from worker auth-service where the path contains /login"
     *
     * 		### Calculation View
     * 		- "What is the p99 of wall time for worker api-proxy?"
     * 		- "What's the count of requests by status code for worker cdn-router?"
     *
     * 		### Invocation View
     * 		- "Find a request to worker api-proxy that resulted in a 500 error"
     * 		- "List successful requests for the image-resizer worker with status code 200"
     *
     */
    view?: "events" | "calculations" | "invocations";
    parameters: {
      /**
       * Leave this empty to use the default datasets
       */
      datasets?: string[];
      filters?: {
        /**
         * Filter field name. IMPORTANT:
         *
         *     • DO NOT guess keys - always use verified keys from either:
         *       - Previous query results
         *       - The observability_keys response
         *
         *     • PREFERRED KEYS (faster & always available):
         *       - $metadata.service: Worker service name
         * 			- $metadata.origin: Trigger type (e.g., fetch, scheduled, etc.)
         * 			- $metadata.trigger: Trigger type (e.g., GET /users, POST /orders, etc.)
         *       - $metadata.message: Log message text (present in nearly all logs)
         *       - $metadata.error: Error message (when applicable)
         *
         */
        key: string;
        operation:
          | "includes"
          | "not_includes"
          | "starts_with"
          | "regex"
          | "exists"
          | "is_null"
          | "in"
          | "not_in"
          | "eq"
          | "neq"
          | "gt"
          | "gte"
          | "lt"
          | "lte";
        /**
         * Filter comparison value. IMPORTANT:
         *
         *     • MUST match actual values in your logs
         *     • VERIFY using either:
         *       - Actual values from previous query results
         *       - The '/values' endpoint with your selected key
         *
         *     • TYPE MATCHING:
         *       - Ensure value type (string/number/boolean) matches the field type
         *       - String comparisons are case-sensitive unless using specific operations
         *
         *     • PATTERN USAGE:
         *       - For 'contains', use simple wildcard patterns
         *       - For 'regex', MUST use ClickHouse regex syntax:
         *         - Uses RE2 syntax (not PCRE/JavaScript)
         *         - No lookaheads/lookbehinds
         *         - Examples: '^5\d{2}$' for HTTP 5xx codes, '\bERROR\b' for word boundary
         *         - Escape backslashes with double backslash
         */
        value?: string | number | boolean;
        type: "string" | "number" | "boolean";
      }[];
      filterCombination?: "and" | "or" | "AND" | "OR";
      calculations?: {
        /**
         * The key to use for the calculation. This key must exist in the logs.
         * Use the Keys endpoint to confirm that this key exists
         *
         * • DO NOT guess keys - always use verified keys from either:
         * - Previous query results
         * - The observability_keys response
         */
        key?: string;
        keyType?: "string" | "number" | "boolean";
        operator:
          | "uniq"
          | "count"
          | "max"
          | "min"
          | "sum"
          | "avg"
          | "median"
          | "p001"
          | "p01"
          | "p05"
          | "p10"
          | "p25"
          | "p75"
          | "p90"
          | "p95"
          | "p99"
          | "p999"
          | "stddev"
          | "variance";
        alias?: string;
      }[];
      /**
       * Only valid when doing a Calculation
       */
      groupBys?: {
        type: "string" | "number" | "boolean";
        value: string;
      }[];
      /**
       * Order By only workers when a group by is present
       */
      orderBy?: {
        /**
         * This must be the alias of a calculation
         */
        value: string;
        order?: "asc" | "desc";
      };
      /**
       * Use this limit when view is calculation and a group by is present. 10 is a sensible default
       */
      limit?: number;
      needle?: {
        /**
         * Filter comparison value. IMPORTANT:
         *
         *     • MUST match actual values in your logs
         *     • VERIFY using either:
         *       - Actual values from previous query results
         *       - The '/values' endpoint with your selected key
         *
         *     • TYPE MATCHING:
         *       - Ensure value type (string/number/boolean) matches the field type
         *       - String comparisons are case-sensitive unless using specific operations
         *
         *     • PATTERN USAGE:
         *       - For 'contains', use simple wildcard patterns
         *       - For 'regex', MUST use ClickHouse regex syntax:
         *         - Uses RE2 syntax (not PCRE/JavaScript)
         *         - No lookaheads/lookbehinds
         *         - Examples: '^5\d{2}$' for HTTP 5xx codes, '\bERROR\b' for word boundary
         *         - Escape backslashes with double backslash
         */
        value: string | number | boolean;
        isRegex?: boolean;
        matchCase?: boolean;
      };
    };
    /**
     * Timeframe for your query, which can be either absolute or relative.
     *
     *   • Absolute timeframe: Specify exact start and end times in ISO-8601 format (e.g., "2025-04-29T14:30:00Z").
     *   • Relative timeframe: Specify a reference time and an offset (e.g., reference="2025-04-29T14:30:00Z", offset="-30m").
     *
     *   Examples:
     *   - Absolute: from="2025-04-01T00:00:00Z", to="2025-04-05T23:59:59Z"
     *   - Relative: reference="2025-04-29T14:30:00Z", offset="-30m"
     *
     *   Note: Narrower timeframes provide faster responses and more specific results.
     */
    timeframe:
      | {
          to: string;
          from: string;
        }
      | {
          reference: string;
          offset: string;
        };
    /**
     * This is only used when the view is calculations - by leaving it empty workers observability will detect the correct granularity
     */
    granularity?: number;
    /**
     * Use this limit to limit the number of events returned when the view is events. 5 is a sensible default
     */
    limit?: number;
    dry?: boolean;
    /**
     * The offset to use for pagination. Use the $metadata.id field to get the next offset.
     */
    offset?: string;
    offsetBy?: number;
    /**
     * The direction to use for pagination. Use "next" or "prev".
     */
    offsetDirection?: string;
  };
}

export type QueryworkerobservabilityOutput = unknown;


/**
 * Query the Workers Observability API to analyze logs and metrics from your Cloudflare Workers.

	* A query typical query looks like this:
				{"view":"events","queryId":"workers-logs-events","limit":5,"dry":true,"parameters":{"datasets":["cloudflare-workers"],"filters":[{"id":"520","key":"message","operation":"eq","type":"string","value":"Clickhouse Statistics"},{"id":"2088","key":"statistics.elapsed","operation":"gt","type":"number","value":"0.269481519"}],"calculations":[],"groupBys":[],"havings":[]},"timeframe":{"to":"2025-04-30T20:53:15Z","from":" ""2025-04-30T19:53:15Z"}}
## Core Capabilities
This tool provides three primary views of your Worker data:
1. **List Events** - Browse individual request logs and errors
2. **Calculate Metrics** - Compute statistics across requests (avg, p99, etc.)
3. **Find Specific Invocations** - Locate individual requests matching criteria

## Filtering Best Practices
- Before applying filters, use the observability_keys and observability_values tools to confirm available filter fields and the correct filter value to add unless you have the data in a response from a previous query.
- Common filter fields:  $metadata.service, $metadata.trigger, $metadata.message, $metadata.level, $metadata.requestId,

## Calculation Best Practices
- Before applying calculations, use the observability_keys tools to confirm key that should be used for the calculation

## Troubleshooting
- If no results are returned, suggest broadening the time range or relaxing filters
- For errors about invalid fields, recommend using observability_keys to see available options

 *
 * MCP server: `cloudflare-observability`
 * MCP tool: `query_worker_observability`
 * @param input Tool input
 * @returns Tool output
 */
export async function queryWorkerObservability(input: QueryworkerobservabilityInput): Promise<QueryworkerobservabilityOutput> {
  return await callMcpTool<QueryworkerobservabilityOutput>({
    serverName: "cloudflare-observability",
    toolName: "query_worker_observability",
    input,
  });
}

// CLI execution block
if (process.argv[1] && fileURLToPath(import.meta.url) === process.argv[1]) {
  (async () => {
    try {
      let inputStr = "";
      if (process.stdin.isTTY) {
        // No stdin available, use empty object
        inputStr = "{}";
      } else {
        // Read from stdin (file descriptor 0)
        try {
          inputStr = readFileSync(0, "utf-8").trim();
        } catch {
          // Fallback if readFileSync fails
          inputStr = "";
        }
        if (!inputStr) {
          inputStr = "{}";
        }
      }
      
      const input = JSON.parse(inputStr) as QueryworkerobservabilityInput;
      const result = await queryWorkerObservability(input);
      console.log(JSON.stringify(result, null, 2));
      process.exit(0);
    } catch (error) {
      console.error("Error:", error instanceof Error ? error.message : String(error));
      if (error instanceof Error && error.stack) {
        console.error(error.stack);
      }
      process.exit(1);
    }
  })();
}
