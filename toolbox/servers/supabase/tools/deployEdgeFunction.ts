#!/usr/bin/env tsx
import { callMcpTool } from "@merl-ai/mcp-toolbox-runtime";
import { fileURLToPath } from "node:url";
import { readFileSync } from "node:fs";

// Generated by mcp-toolbox. Do not edit by hand.

export interface DeployedgefunctionInput {
  /**
   * The name of the function
   */
  name: string;
  /**
   * The entrypoint of the function
   */
  entrypoint_path: string;
  /**
   * The import map for the function.
   */
  import_map_path?: string;
  /**
   * Whether to require a valid JWT in the Authorization header. You SHOULD ALWAYS enable this to ensure authorized access. ONLY disable if the function previously had it disabled OR you've confirmed the function body implements custom authentication (e.g., API keys, webhooks) OR the user explicitly requested it be disabled.
   */
  verify_jwt: boolean;
  /**
   * The files to upload. This should include the entrypoint, deno.json, and any relative dependencies. Include the deno.json and deno.jsonc files to configure the Deno runtime (e.g., compiler options, imports) if they exist.
   */
  files: {
    name: string;
    content: string;
  }[];
}

export type DeployedgefunctionOutput = unknown;


/**
 * Deploys an Edge Function to a Supabase project. If the function already exists, this will create a new version. Example:

import "jsr:@supabase/functions-js/edge-runtime.d.ts";

Deno.serve(async (req: Request) => {
  const data = {
    message: "Hello there!"
  };
  
  return new Response(JSON.stringify(data), {
    headers: {
      'Content-Type': 'application/json',
      'Connection': 'keep-alive'
    }
  });
});
 *
 * MCP server: `supabase`
 * MCP tool: `deploy_edge_function`
 * @param input Tool input
 * @returns Tool output
 */
export async function deployEdgeFunction(input: DeployedgefunctionInput): Promise<DeployedgefunctionOutput> {
  return await callMcpTool<DeployedgefunctionOutput>({
    serverName: "supabase",
    toolName: "deploy_edge_function",
    input,
  });
}

// CLI execution block
if (process.argv[1] && fileURLToPath(import.meta.url) === process.argv[1]) {
  (async () => {
    try {
      let inputStr = "";
      if (process.stdin.isTTY) {
        // No stdin available, use empty object
        inputStr = "{}";
      } else {
        // Read from stdin (file descriptor 0)
        try {
          inputStr = readFileSync(0, "utf-8").trim();
        } catch {
          // Fallback if readFileSync fails
          inputStr = "";
        }
        if (!inputStr) {
          inputStr = "{}";
        }
      }
      
      const input = JSON.parse(inputStr) as DeployedgefunctionInput;
      const result = await deployEdgeFunction(input);
      console.log(JSON.stringify(result, null, 2));
      process.exit(0);
    } catch (error) {
      console.error("Error:", error instanceof Error ? error.message : String(error));
      if (error instanceof Error && error.stack) {
        console.error(error.stack);
      }
      process.exit(1);
    }
  })();
}
