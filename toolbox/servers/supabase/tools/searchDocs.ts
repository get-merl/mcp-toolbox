#!/usr/bin/env tsx
import { callMcpTool } from "@merl-ai/mcp-toolbox-runtime";
import { fileURLToPath } from "node:url";
import { readFileSync } from "node:fs";

// Generated by mcp-toolbox. Do not edit by hand.

export interface SearchdocsInput {
  graphql_query: string;
}

export type SearchdocsOutput = unknown;

/**
 * Search the Supabase documentation using GraphQL. Must be a valid GraphQL query.
You should default to calling this even if you think you already know the answer, since the documentation is always being updated.

Below is the GraphQL schema for this tool:

schema{query:RootQueryType}type Guide implements SearchResult{title:String href:String content:String subsections:SubsectionCollection}interface SearchResult{title:String href:String content:String}type SubsectionCollection{edges:[SubsectionEdge!]! nodes:[Subsection!]! totalCount:Int!}type SubsectionEdge{node:Subsection!}type Subsection{title:String href:String content:String}type CLICommandReference implements SearchResult{title:String href:String content:String}type ManagementApiReference implements SearchResult{title:String href:String content:String}type ClientLibraryFunctionReference implements SearchResult{title:String href:String content:String language:Language! methodName:String}enum Language{JAVASCRIPT SWIFT DART CSHARP KOTLIN PYTHON}type TroubleshootingGuide implements SearchResult{title:String href:String content:String}type RootQueryType{schema:String! searchDocs(query:String!,limit:Int):SearchResultCollection error(code:String!,service:Service!):Error errors(first:Int after:String last:Int before:String service:Service code:String):ErrorCollection}type SearchResultCollection{edges:[SearchResultEdge!]! nodes:[SearchResult!]! totalCount:Int!}type SearchResultEdge{node:SearchResult!}type Error{code:String! service:Service! httpStatusCode:Int message:String}enum Service{AUTH REALTIME STORAGE}type ErrorCollection{edges:[ErrorEdge!]! nodes:[Error!]! pageInfo:PageInfo! totalCount:Int!}type ErrorEdge{node:Error! cursor:String!}type PageInfo{hasNextPage:Boolean! hasPreviousPage:Boolean! startCursor:String endCursor:String}
 *
 * MCP server: `supabase`
 * MCP tool: `search_docs`
 * @param input Tool input
 * @returns Tool output
 */
export async function searchDocs(input: SearchdocsInput): Promise<SearchdocsOutput> {
  return await callMcpTool<SearchdocsOutput>({
    serverName: "supabase",
    toolName: "search_docs",
    input,
  });
}

// CLI execution block
if (process.argv[1] && fileURLToPath(import.meta.url) === process.argv[1]) {
  (async () => {
    try {
      let inputStr = "";
      if (process.stdin.isTTY) {
        // No stdin available, use empty object
        inputStr = "{}";
      } else {
        // Read from stdin (file descriptor 0)
        try {
          inputStr = readFileSync(0, "utf-8").trim();
        } catch {
          // Fallback if readFileSync fails
          inputStr = "";
        }
        if (!inputStr) {
          inputStr = "{}";
        }
      }

      const input = JSON.parse(inputStr) as SearchdocsInput;
      const result = await searchDocs(input);
      console.log(JSON.stringify(result, null, 2));
      process.exit(0);
    } catch (error) {
      console.error("Error:", error instanceof Error ? error.message : String(error));
      if (error instanceof Error && error.stack) {
        console.error(error.stack);
      }
      process.exit(1);
    }
  })();
}
